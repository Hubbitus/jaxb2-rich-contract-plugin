<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.8.1 from src/site/markdown/fluent-builder_de.md at 2018-08-30
 | Rendered using Apache Maven Fluido Skin 1.7
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20180830" />
    <meta http-equiv="Content-Language" content="en" />
    <title>jaxb2-rich-contract-plugin &#x2013; fluent-builder</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.7.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script type="text/javascript" src="./js/apache-maven-fluido-1.7.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>JAXB XJC extended contract generation plugin</h2>
</div>
</div>
        <div class="pull-right"></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2018-08-30<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 2.0.0-SNAPSHOT</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
    <ul class="nav nav-list">
      <li class="nav-header">Getting Started</li>
    <li><a href="index.html" title="Overview"><span class="none"></span>Overview</a></li>
    <li><a href="getting.html" title="Download"><span class="none"></span>Download</a></li>
    <li><a href="history.html" title="Version History"><span class="none"></span>Version History</a></li>
    <li><a href="usage.html" title="Usage"><span class="none"></span>Usage</a></li>
      <li class="nav-header">XJC Plugin Options</li>
    <li><a href="fluent-builder.html" title="fluent-builder"><span class="none"></span>fluent-builder</a></li>
    <li><a href="group-contract.html" title="group-contract"><span class="none"></span>group-contract</a></li>
    <li><a href="immutable.html" title="immutable"><span class="none"></span>immutable</a></li>
    <li><a href="modifier.html" title="modifier"><span class="none"></span>modifier</a></li>
    <li><a href="clone.html" title="clone"><span class="none"></span>clone</a></li>
    <li><a href="copy.html" title="copy"><span class="none"></span>copy</a></li>
    <li><a href="constrained-properties.html" title="constrained-properties"><span class="none"></span>constrained-properties</a></li>
    <li><a href="meta.html" title="meta"><span class="none"></span>meta</a></li>
      <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
</ul>
          <hr />
          <div id="poweredBy">
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<div class="section">
<h2><a name="fluent-builder"></a>fluent-builder</h2>
<div class="section">
<h3><a name="Motivation"></a>Motivation</h3>
<p>There already is the widely used &#x201c;fluent-api&#x201d; plugin for XJC. That, however isn&#x2019;t a real builder pattern since there is no distinction between initialization and state change in fluent-api.</p>
<p>fluent-builder now creates a real &#x201c;Builder&#x201d; pattern, implemented as an inner class to the generated classes.</p></div>
<div class="section">
<h3><a name="Funktion"></a>Funktion</h3>
<p>fluent-builder creates a builder class with a &#x201c;<a class="externalLink" href="https://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a>&#x201d;, and a number of methods to create builder instances. The builder class is generated as a static inner class to all of the value object classes generated with XJC. It supports the &#x201c;episode&#x201d; mechanism to generate builder code seamlessly across multiple compilation schema modules.</p>
<p>Example use in code:</p>

<div>
<div>
<pre class="source">    MyElement newElement = MyElement.builder().withPropertyA(...).withPropertyB(...).addCollectionPropertyA(...).build();
</pre></div></div>

<div class="section">
<h4><a name="Additional_Features"></a>Additional Features</h4>
<div class="section">
<h5><a name="a.E2.80.9CChoice_Expansion.E2.80.9D"></a>&#x201c;Choice Expansion&#x201d;</h5>
<p>In standard JAXB, if you define a <tt>&lt;choice&gt;</tt> group in an XSD complexType definition with cardinality &#x201c;many&#x201d;, the generated code will only contain a generic collection of &#x201c;java.lang.Object&#x201d; type, named something like &#x201c;AorBorC&#x2026;&#x201d;.</p>
<p>However, fluent-builder will determine exactly which types are actually possible in this collection, and will generate individual &#x201c;addXXX&#x201d; methods for each of them.</p>
<p>So, imagine you have generated code from the XHTML 1.0 schema, and you wish to use fluent-builder to generate an XHTML document programmatically. Now, again imagine you have already created the &#x201c;html&#x201d; and &#x201c;head&#x201d; elements, and you are about to populate the &#x201c;body&#x201d; eith a table.</p>
<p>Without fluent-builder, you would do something like:</p>

<div>
<div>
<pre class="source">Body body = new Body();
Table table = new Table();
body.getPorH2orH2().add(table);
Tr tr = new Tr();
table.getTheadOrTrOrTdata().add(tr);
Td td = new Td();
tr.getTd().add(td);
td.setContent(&quot;Hello World&quot;);
</pre></div></div>

<p>With fluent-builder, you can achieve the same more intuitively:</p>

<div>
<div>
<pre class="source">Body.builder().addTable().addTr().addTd().withContent(&quot;Hello World&quot;).end().end().end().build();
</pre></div></div>
</div>
<div class="section">
<h5><a name="Object_Deep-Copy_strategies_and_Behaviors"></a>Object Deep-Copy strategies and Behaviors</h5>
<p>In addition, new instances can be created as copies of existing instances using the builder, with an optional modification by other builder methods:</p>
<div class="section">
<h6><a name="Static_Deep_Copy"></a>Static Deep Copy</h6>

<div>
<div>
<pre class="source">    MyElement newElement = MyElement.copyOf(oldElement).withPropertyA(...).withPropertyB(...).build();
</pre></div></div>

<p>Or, similar to the java <tt>clone()</tt> method, creating a runtime copy of a reference:</p></div>
<div class="section">
<h6><a name="Polymorphic_Deep_Copy"></a>Polymorphic Deep Copy</h6>

<div>
<div>
<pre class="source">	MyObj myObj = oldObj.newCopyBuilder().with... .build();
</pre></div></div>
</div>
<div class="section">
<h6><a name="Partial_Copy_.28Static_and_Polymorphic.29"></a>Partial Copy (Static and Polymorphic)</h6>
<p>The &#x201c;partial&#x201d; copy introduced in the &#x201c;copy&#x201d; plugin will work here as well, with both static (<tt>copyOf()</tt>) as well as polymorphic (<tt>newCopyBuilder()</tt>) behaviors:</p>

<div>
<div>
<pre class="source">    PropertyTree selection = MyElement.Select.root().propertyA().propertyAB().build();
    MyElement newElement = MyElement.copyExcept(oldElement, selection).withPropertyA(...).withPropertyB(...).build();
	MyObj myObj = oldObj.newCopyBuilder(selection, PropertyTreeUse.EXCLUDE).with.... .build();
</pre></div></div>
</div>
<div class="section">
<h6><a name="Static_vs._Polymorphic_Deep_Copy"></a>Static vs. Polymorphic Deep Copy</h6>
<p>The difference between <tt>copyOf()</tt> and <tt>newCopyBuilder()</tt> is their respective polymorphic behavior. <tt>newCopyBuilder()</tt> always returns a builder instance that corresponds to the current runtime type of the object upon which the <tt>newCopyBuilder()</tt> method was invoked. I.e., using <tt>newCopyBuilder()</tt>, you always get an object of exactly the same type as before as soon as you call <tt>build()</tt>.</p>
<p>In contrast, <tt>MyClass.copyOf()</tt>, being a static method, always returns an object of the class on which it is called, <tt>MyClass</tt> in this case. You can pass an object of any base type (from the same XSD model or one referenced via &#x201c;episode&#x201d;) or any derived type of <tt>MyClass</tt> to <tt>copyOf()</tt>, and you still get an instance of <tt>MyClass</tt> as soon as you call <tt>build()</tt>. If you pass an instance of a more general class than <tt>MyClass</tt> to <tt>MyClass.copyOf()</tt>, the generated code will only copy the fields that exist in the argument object, and will leave all additional fields uninitialized. You should then initialize them with the other builder methods.</p></div></div>
<div class="section">
<h5><a name="Chained_Builder_Support"></a>Chained Builder Support</h5>
<p>Often, properties of generated classes represent containment or references to generated classes in the same model. The fluent-builder plugin lets you initialise properties of such a type (and of types declared in upstream modules via the &#x201c;episode&#x201d; feature) - if it isn&#x2019;t an abstract type - by using sub-builders (&#x201c;chained&#x201d; builders) in the following way, given that both A and B are types defined in the XSD model, and A has a property of type B, and B has three properties of type String, x,y, and z:</p>

<div>
<div>
<pre class="source">    A newA = A.builder().withB().withX(&quot;x&quot;).withY(&quot;y&quot;).withZ(&quot;z&quot;).end().build();
</pre></div></div>

<p>Of course, this plugin is most useful if <tt>immutable</tt> is also activated.</p></div></div></div>
<div class="section">
<h3><a name="Enschr.C3.A4nkungen"></a>Enschr&#xe4;nkungen</h3>
<ul>

<li>It generates a large amount of code.</li>
<li>Note: Shared builder instances are NOT thread-safe by themselves.</li>
</ul></div>
<div class="section">
<h3><a name="Aktivierung"></a>Aktivierung</h3>
<div class="section">
<h4><a name="a-Xfluent-builder"></a>-Xfluent-builder</h4></div>
<div class="section">
<h4><a name="Optionen"></a>Optionen</h4>
<div class="section">
<h5><a name="a-rootSelectorClassName.3D.3Cstring.3E_.28Select.29"></a>-rootSelectorClassName=<tt>&lt;string&gt;</tt> (Select)</h5>
<p>Name der generierten inneren &#x201c;Select&#x201d; -Klasse, die vom aufrufenden Code als Einstieg in den Aufbau eines Property-Baumes f&#xfc;r das partielle Kopieren verwendet werden kann. Diese Einstellung wird nur dann ber&#xfc;cksichtigt, wenn das &#x201c;Deep Copy&#x201d;-Plugin nicht aktiv ist, und &#x201c;copy-partial=y&#x201d; ist. Ansonsten gilt die Einstellung des &#x201c;Deep Copy&#x201d;-Plugins.</p></div>
<div class="section">
<h5><a name="a-newBuilderMethodName.3D.3Cstring.3E_.28builder.29"></a>-newBuilderMethodName=<tt>&lt;string&gt;</tt> (builder)</h5>
<p>Name der generierten statischen Methode zum Erzeugen eines neuen Builders. Kann hier gesetzt werden, um Namenskonflikte zu l&#xf6;sen.</p></div>
<div class="section">
<h5><a name="a-newCopyBuilderMethodName.3D.3Cstring.3E_.28newCopyBuilder.29"></a>-newCopyBuilderMethodName=<tt>&lt;string&gt;</tt> (newCopyBuilder)</h5>
<p>Name der generierten Instanzmethode zum Erzeugen eines neuen Builders, der mit dem von dieser Instanz kopierten Zustand initialisiert ist.</p></div>
<div class="section">
<h5><a name="a-copyToMethodName.3D.3Cstring.3E_.28copyTo.29"></a>-copyToMethodName=<tt>&lt;string&gt;</tt> (copyTo)</h5>
<p>Name der generierten Methode zum kopieren des internen Zustands dieses Builders auf einen anderen Builder.</p></div>
<div class="section">
<h5><a name="a-builderFieldSuffix.3D.3Cstring.3E_.28_Builder.29"></a>-builderFieldSuffix=<tt>&lt;string&gt;</tt> (_Builder)</h5>
<p>Suffix, das an den Namen der generierten Sub-Builder Instanzvariablen angef&#xfc;gt wird.</p></div>
<div class="section">
<h5><a name="a-generateTools.3D.7By.7Cn.7D_.28y.29"></a>-generateTools=<tt>{y|n}</tt> (y)</h5>
<p>Generiere Hilfsklassen als Quelltext. Wenn dies ausgeschaltet ist, muss sich das Plugin-JAR zur Laufzeit im Klassenpfad der generierten Klassendefinitionen befinden.</p></div>
<div class="section">
<h5><a name="a-narrow.3D.7By.7Cn.7D_.28n.29"></a>-narrow=<tt>{y|n}</tt> (n)</h5>
<p>F&#xfc;r untergeordnete Knoten im zu kopierenden Objektbaum werden ebenfalls die Copy-Konstruktoren der deklarierten Typen verwendet, soweit diese vorhanden sind und die Typen der entsprechenden Instanzen ebenfalls aus dem XSD-Model generierte Klassen sind. Dies erzeugt eine m&#xf6;glichst &#x201c;schmale&#x201d; Kopie des Ausgangsobjekts, was in bestimmten F&#xe4;llen n&#xfc;tzlich sein kann. Ein Unterknoten, dessen Typ nicht im aktuellen XSD-Modell deklariert ist, wird immer wie bei der &#x2018;clone()&#x2019;-Methode kopiert. Ist diese Option &#x201c;no&#x201d;, gilt dies auch f&#xfc;r generierte Typen.</p></div>
<div class="section">
<h5><a name="a-copyPartial.3D.7By.7Cn.7D_.28y.29"></a>-copyPartial=<tt>{y|n}</tt> (y)</h5>
<p>Generiert zus&#xe4;tzlich eine &#x2018;copyOf()&#x2019;-Methode mit der sich Objekte partiell kopieren lassen. Dabei wird ein PropertyTree-Objekt mitgegeben, welches die zu kopierenden Knoten des Objektbaumes angibt.</p></div>
<div class="section">
<h5><a name="a-selectorClassName.3D.3Cstring.3E_.28Selector.29"></a>-selectorClassName=<tt>&lt;string&gt;</tt> (Selector)</h5>
<p>Name der generierten inneren &#x201c;Selector&#x201d; Builder-Klasse, die intern zum Aufbau des Property-Baums f&#xfc;r das partielle Kopieren benutzt wird. Diese Einstellung wird nur dann ber&#xfc;cksichtigt, wenn das &#x201c;Deep Copy&#x201d;-Plugin nicht aktiv ist, und &#x201c;copy-partial=y&#x201d; ist. Ansonsten gilt die Einstellung des &#x201c;Deep Copy&#x201d;-Plugins.</p></div>
<div class="section">
<h5><a name="a-builderClassName.3D.3Cstring.3E_.28Builder.29"></a>-builderClassName=<tt>&lt;string&gt;</tt> (Builder)</h5>
<p>Name der generierten inneren Builder-Klasse. Kann hier gesetzt werden, um Namenskonflikte zu l&#xf6;sen.</p></div>
<div class="section">
<h5><a name="a-builderInterfaceName.3D.3Cstring.3E_.28BuildSupport.29"></a>-builderInterfaceName=<tt>&lt;string&gt;</tt> (BuildSupport)</h5>
<p>Name des generierten inneren Builder-Interfaces. Kann hier gesetzt werden, um Namenskonflikte zu l&#xf6;sen.</p></div>
<div class="section">
<h5><a name="a-copyAlways.3D.7By.7Cn.7D_.28n.29"></a>-copyAlways=<tt>{y|n}</tt> (n)</h5>
<p>Ist diese Option &#x2018;yes&#x2019;, werden alle withXXX-Methoden, die JAXB-generierte Objekte akzeptieren, so generiert, dass die &#xfc;bergebenen Objekte kopiert werden.</p></div>
<div class="section">
<h5><a name="a-buildMethodName.3D.3Cstring.3E_.28build.29"></a>-buildMethodName=<tt>&lt;string&gt;</tt> (build)</h5>
<p>Name der generierten &#x201c;build&#x201d;-Methode, die das gebaute Objekt zur&#xc3;&#xbc;ckliefert.</p></div>
<div class="section">
<h5><a name="a-endMethodName.3D.3Cstring.3E_.28end.29"></a>-endMethodName=<tt>&lt;string&gt;</tt> (end)</h5>
<p>Name der generierten &#x201c;end&#x201d;-Methode, die einen sub-Builder beendet.</p></div></div></div></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2018.
All rights reserved.</p>
        </div>
      </div>
    </footer>
  </body>
</html>
