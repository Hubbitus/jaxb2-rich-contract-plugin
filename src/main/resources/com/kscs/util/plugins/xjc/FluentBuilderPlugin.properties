usage.fluentBuilderGenerateTools=Generate utility classes as source code. If you say "no" here, you will have to add the plugin JAR \
  to the runtime classpath of the generated class domain.
usage=Generates an inner fluent builder for JAXB classes. Optionally, copy constructor and partial clone functionality can be generated.
usage.narrow=Uses copy constructors for all child nodes in the object tree as long as they are available. This \
  will cause the new instance to be as narrow as possible to the declared types.\nAbstract types and types not generated \
  from this XSD-modle will always be copied by their "clone()"-method.
usage.copyPartial=Generates an additional 'copyOf'-method  \
  that takes a PropertyTree instance to restrict the copy operation to selected nodes in the object tree.
usage.generateTools=Generate utility classes as static source code artifacts. If no, the plugin JAR must be in compile- and runtime classpath.
usage.selectorClassName=Name of the generated nested "Selector" builder class, used to build up a property tree for partial copy functionality. \
  This setting will only have an effect if the "deep-copy-plugin" isn't also active. If it is, the "copy" plugin's settings will take precedence.
usage.rootSelectorClassName=Name of the generated nested static "Select" entry point class to be used by client code for the "partial copy" feature. \
  This setting will only have an effect if the "deep-copy-plugin" isn't also active. If it is, the "copy" plugin's settings will take precedence.
usage.builderClassName=Name of the generated nested builder class. Can be set to handle naming conflicts.
usage.newBuilderMethodName=Name of the generated static method to instantiate a new fluent builder. Can be set to handle naming conflicts.
error.builderClassExists=Class "{0}" already contains inner class "Builder". Skipping generation of fluent builder.
doc.motivation=There already is the widely used "fluent-api" plugin for XJC. That, however isn't a real builder pattern since there is no strict programmatic distinction between initialization and state change in fluent-api.\n\n\
fluent-builder now creates a real "Builder" pattern, implemented as an inner class to the generated classes.
doc.function=fluent-builder creates a static inner class for every generated class representing the builder, and a static method on the generated class to create a builder.\n\n\
If the "immutable" plugin is also activated, publicly exposed collections will be immutable, too.\n\n\
Example use in code\:\n\ntt\
        MyElement newElement \= MyElement.builder().withPropertyA(...).withPropertyB(...).addCollectionPropertyA(...).build();\n\n\
In addition, new instances can be created as copies of existing instances using the builder, with an optional modification by other builder methods\:\n\ntt\
        MyElement newElement \= MyElement.copyOf(oldElement).withPropertyA(...).withPropertyB(...).build();\n\n\
The "partial" copy introduced in the "clone" plugin will work here as well\:\n\ntt\
        PropertyTree selection \= MyElement.Select.root().propertyA().propertyAB().build();\ntt\
        MyElement newElement \= MyElement.copyExcept(oldElement, selection).withPropertyA(...).withPropertyB(...).build();\n\n\
Often, properties of generated classes represent containment or references to generated classes in the same model. The fluent-builder plugin lets you initialise properties of such a type - if it isn't an abstract type - by using sub-builders ("chained" builders) in the following way, given that both A and B are types defined in the XSD model, and A has a property of type B, and B has three properties of type String, x,y, and z\:\n\ntt\
        A newA \= A.builder().withB().withX("x").withY("y").withZ("z").end().build();\n\n\
Of course, this plugin is most useful if `immutable` is also activated.
doc.limitations=* It generates a large amount of code.\n\
* Note: Shared builder instances are NOT thread-safe by themselves.
